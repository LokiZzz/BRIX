using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace BRIX.SourceGenerator
{
    [Generator]
    public class ResourceKeysGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var classProvider = context.SyntaxProvider
                                       .CreateSyntaxProvider(Predicate, Transform)
                                       .Collect();

            context.RegisterSourceOutput(classProvider, Generate);
        }

        private bool Predicate(SyntaxNode node, CancellationToken token)
        {
            if (node is ClassDeclarationSyntax cds)
            {
                return cds.Identifier.Text == "Localization";
            }
            return false;
        }

        private ITypeSymbol Transform(GeneratorSyntaxContext context, CancellationToken token)
        {
            var cds = (ClassDeclarationSyntax)context.Node;
            return (ITypeSymbol)context.SemanticModel.GetDeclaredSymbol(cds)!;
        }

        private void Generate(SourceProductionContext context, ImmutableArray<ITypeSymbol> collection)
        {
            if (collection.IsDefaultOrEmpty)
            {
                return;
            }

            foreach (var type in collection)
            {
                var code = GenerateCode(type);
                var typeNamespace = type.ContainingNamespace.IsGlobalNamespace ? null : $"{type.ContainingNamespace}.";
                context.AddSource($"{typeNamespace}{type.Name}Keys.g.cs", code);
            }
        }

        private string GenerateCode(ITypeSymbol type)
        {
            var ns = type.ContainingNamespace.IsGlobalNamespace ? null : type.ContainingNamespace.ToString();
            var name = type.Name+"Keys";
            var keys = GetKeys(type);

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine($"namespace {ns}");
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic class {name}");
            sb.AppendLine("\t{");
            sb.AppendLine($"\t\tpublic {name}() {{ }}");
            foreach (var key in keys)
            {
                sb.AppendLine($"\t\tpublic static string {key} => \"{key}\";");
            }

            sb.AppendLine("\t}");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private IEnumerable<string> GetKeys(ITypeSymbol type)
        {
            return type.GetMembers()
                       .Select(m =>
                       {
                           if (m is not IPropertySymbol prop
                                || !prop.IsStatic
                                || prop.DeclaredAccessibility != Accessibility.Public
                                || prop.Type.Name != "String")
                           {
                               return null;
                           }

                           return prop.Name;
                       })
                       .Where(prop => prop is not null)!;
        }
    }
}
