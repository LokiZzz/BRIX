using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml.Linq;

namespace BRIX.SourceGenerator
{
    public class FileGroup
    {
        public FileGroup(AdditionalText mainFile, IReadOnlyList<AdditionalText> subFiles)
        {
            MainFile = mainFile;
            SubFiles = subFiles.OrderBy(x => x.Path).ToArray();
        }

        public AdditionalText MainFile { get; }
        public IReadOnlyList<AdditionalText> SubFiles { get; }

        public (string Name, string SourceCode) GenerateFile(GlobalOptions options, CancellationToken cancellationToken = default)
        {
            cancellationToken.ThrowIfCancellationRequested();

            string @namespace = GetLocalNamespace(MainFile.Path, options.ProjectFullPath, options.RootNamespace);
            string name = Path.GetFileNameWithoutExtension(MainFile.Path) + "Keys";
            var content = MainFile.GetText(cancellationToken);
            List<string> keys = ReadResxKeys(content!);

            foreach (AdditionalText subFile in SubFiles)
            {
                List<string> subKeys = ReadResxKeys(subFile.GetText()!);
                keys.AddRange(subKeys);
            }

            keys = keys
                .Distinct()
                .OrderBy(str => str)
                .ToList();
            string sourceCode = GetSourceCode(name, @namespace, keys);

            return ($"{@namespace}.{name}.g.cs", sourceCode);
        }

        private string GetSourceCode(string className, string namespaceName, List<string> keys)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated />");
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine($"\tpublic class {className}");
            sb.AppendLine("\t{");
            sb.AppendLine($"\t\tpublic {className}() {{ }}");

            foreach (var key in keys)
            {
                var value = Regex.IsMatch(key, @"^\d+") ? "_" + key : key;
                sb.AppendLine($"\t\tpublic static string {value} => \"{value}\";");
            }

            sb.AppendLine("\t}");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private string GetLocalNamespace(string resxPath, string projectPath, string rootNamespace)
        {
            var resxFolder = Path.GetDirectoryName(resxPath);
            var projectFolder = Path.GetDirectoryName(projectPath);

            var localNamespace = resxFolder.Substring(projectFolder.Length)
                    .Trim(Path.DirectorySeparatorChar)
                    .Trim(Path.AltDirectorySeparatorChar)
                    .Replace(Path.DirectorySeparatorChar, '.')
                    .Replace(Path.AltDirectorySeparatorChar, '.');

            return string.IsNullOrEmpty(localNamespace) ? rootNamespace : $"{rootNamespace}.{localNamespace}";
        }

        private List<string> ReadResxKeys(SourceText content)
        {
            using (StringReader reader = new(content.ToString()))
            {
                return XDocument.Load(reader, LoadOptions.SetLineInfo)
                    .Root
                    .Descendants()
                    .Where(data => data.Name == "data")
                    .Select(data => data.Attribute("name")!.Value)
                    .ToList();
            }
        }
    }
}
